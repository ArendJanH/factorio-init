#!/bin/bash

# Load config file
if [ -L $0 ]; then
  source `readlink -e $0 | sed "s:[^/]*$:config:"`
else
  source `echo $0 | sed "s:[^/]*$:config:"`
fi

# Check/load defaults for backwards compatible config options
if [ -z "${PACKAGE_DIR_NAME}" ]; then
  PACKAGE_DIR_NAME=factorio
fi
if [ -z ${USERGROUP} ]; then
  USERGROUP=${USERNAME}
fi

if [ "$SERVICE_NAME" == "" ];then
  echo "Couldn't load config file, please edit config.example and rename it to config"
  logger -t factorio-init "Couldn't load config file, please edit config.example and rename it to config"
  exit
fi

if [ ! -f "$BINARY" ]; then
  echo "Failed to start: Can't find the specified binary $BINARY. Please check your config!"
  exit 1
fi

debug(){
  if [ ${DEBUG} -gt 0 ]; then
    echo "DEBUG LOG: $@" >&2
  fi
}

usage(){
  echo "Usage: $0 COMMAND"
  echo
  echo "Available commands:"
  echo -e "   start \t\t Starts the server"
  echo -e "   stop \t\t Stops the server"
  echo -e "   restart \t\t Restarts the server"
  echo -e "   status \t\t Displays server status"
  echo -e "   load-save [name] \t Loads the specified save"
  echo -e "   screen \t\t Shows the server screen"
  echo -e "   update [tarball] \t Updates/Installs the server with specified tarball"
}

# Refrain from changing the variables below, they are used internally by the script and should
# not be altered unless you know what you are doing

SCREEN_NAME=${SERVICE_NAME}-screen
PIDFILE=${FACTORIO_PATH}/${SERVICE_NAME}-service.pid
SAVE_NAME=factorio-init-save
INVOCATION="${BINARY} --start-server ${SAVE_NAME} --autosave-interval ${AUTOSAVE_INTERVAL} --autosave-slots ${AUTOSAVE_SLOTS} --latency-ms ${LATENCY}"
debug ${INVOCATION}

ME=`whoami`
as_user() {
  if [ $ME == $USERNAME ]; then
    bash -c "$1"
  else
    su $USERNAME -s /bin/bash -c "$1"
  fi
}

refresh_save(){
  savedir="${FACTORIO_PATH}/saves"

  # Check to see if save dir actually exists
  if ! [ -e ${savedir} ]; then
    echo "Error! Save directory missing: ${savedir}"
    exit 1
  fi

  # Find the last modified save file
  lastsave=$(as_user "ls -t ${savedir}/*.zip" 2> /dev/null | head -1)
  
  # Sanity check, did we even find any save files?
  if [ -z "${lastsave}" ]; then
    echo "Error! Unable to find any saves in ${savedir}"
    exit 1
  fi

  debug "last modified save: ${lastsave}"
  
  # If the last modified save is our own, keep using it
  if [ "${lastsave}" == "${savedir}/${SAVE_NAME}.zip" ]; then
    debug "using existing ${SAVE_NAME}.zip"
    return 0
  fi

  # Else we copy the latest save to our own save file
  debug "using refreshed save"
  if ! as_user "cp ${lastsave} ${savedir}/${SAVE_NAME}.zip"; then
    echo "Error! Failed to refresh saves"
    exit 1
  fi
}

find_pid(){
  pid=$(ps ax | grep -v grep | grep "${BINARY} --start-server ${SAVE_NAME}" | grep -v "${SCREEN_NAME}" | awk '{ print $1}')

  if [ "$pid" == "" ]; then
    echo "-1"
    debug "could not find a pid for binary: \"${BINARY}\""
  else
    echo ${pid}
    debug "found pid: $pid"
  fi
}

is_running() {
  # Checks for the factorio servers screen session
  # returns true if it exists.
  if [ -f "$PIDFILE" ]; then
    pid=$(head -1 $PIDFILE)
    actual_pid=$(find_pid)
    debug "comparing pidfile pid \"${pid}\" with actual pid: ${actual_pid}"
    if [ "${pid}" == "${actual_pid}" ]; then
      return 0
    else
      if [ -z "$isInStop" ]; then
        debug "Removing rogue PIDFILE."
        as_user "rm -f ${PIDFILE}"
      fi
      return 1
    fi
  else
    pid=$(find_pid)
    if [ ${pid} -gt 0 ]; then
      debug "No PIDFILE found, but server is running."
      debug "Re-creating PIDFILE."

      check_permissions
      as_user "echo ${pid} > $PIDFILE"

      return 0
    else
      return 1
    fi
  fi
}

start_service() {

  check_permissions

  refresh_save
  as_user "cd $FACTORIO_PATH && screen -dmS $SCREEN_NAME $INVOCATION"
  if [ $? -eq 0 ]; then
    #
    # Waiting for the server to start
    #
    seconds=0
    until is_running; do
      sleep 1
      seconds=$seconds+1
      if [[ $seconds -eq 2 ]]; then
        echo "Still not running, waiting a while longer..."
      fi
      if [[ $seconds -ge 10 ]]; then
        echo "Failed to start, aborting."
        exit 1
      fi
    done
    echo "$SERVICE_NAME is running."
  else
    echo "Failed to start, ensure SCREEN is installed"
  fi
}

stop_service() {

  #
  # Stops the server
  #
  pid=$(head -1 $PIDFILE)
  as_user "kill -s 2 $pid"
  sleep 0.5
  
  #
  # Waiting for the server to shut down
  #
  seconds=0
  isInStop=1
  while is_running; do
    sleep 1
    seconds=$seconds+1
    if [[ $seconds -eq 2 ]]; then
      echo "Still not shut down, waiting a while longer..."
    fi
    if [[ $seconds -ge 10 ]];
      then
      logger -t factorio-init "Failed to shut down server, aborting."
      echo "Failed to shut down, aborting."
      exit 1
    fi
  done
  
  as_user "rm $PIDFILE"
  unset isInStop
  echo "$SERVICE_NAME is now shut down."
}

check_permissions() {
  as_user "touch $PIDFILE"
  if ! as_user "test -w '$PIDFILE'" ; then
    echo "Check Permissions. Cannot write to $PIDFILE. Correct the permissions and then excute: $0 status"
    return 1
  fi

  return 0
}

update(){
  # Factorio comes packaged in a directory named "factorio"
  # Unless overriden in the config we will presume this is also the
  # name used in FACTORIO_PATH else we abort to prevent messing up
  # peoples installs - call it backwards compatibility if you will.

  expected_path="`dirname ${FACTORIO_PATH}`/${PACKAGE_DIR_NAME}"
  if ! [ "${FACTORIO_PATH}" == "${expected_path}" ]; then
    echo "Aborting update! FACTORIO_PATH does not match expected path: ${expected_path}"
    echo "See config option PACKAGE_DIR_NAME for more details"
    exit 1
  fi

  tarball=$1
  if ! [ -f "${tarball}" ]; then
    echo "Update package does not exist! ${tarball}"
    exit 1
  fi

  target="`dirname ${FACTORIO_PATH}`"
  if ! test -w "${target}"; then
    echo "Failed to write, aborting update!"
    echo "Update needs to be run as a user with write permissions to ${target}"
    exit 1
  fi

  if is_running; then
    stop_service
  fi
  
  echo "Applying update ${tarball} ..."
  if ! tar -xzvf "${tarball}" --directory "${target}"; then
    echo "Update failed!"
    exit 1
  fi
  echo "Applying file ownership ..."
  if ! chown -R ${USERNAME}:${USERGROUP} ${FACTORIO_PATH}; then
    echo "Failed to apply ownership ${USERNAME}:${USERGROUP} for ${FACTORIO_PATH}"
    exit 1
  fi

  echo "Update successfull!"
}

case "$1" in
  start)
    # Starts the server
    if is_running; then
      echo "Server already running."
    else
       start_service
    fi
    ;;
  stop)
    # Stops the server
    if is_running; then
      stop_service
    else
      echo "No running server."
    fi
    ;;
  restart)
    # Restarts the server
    if is_running; then
      stop_service
    else
      echo "No running server, starting it..."
    fi
    start_service
    ;;
  status)
    # Shows server status
    if is_running; then
      echo "$SERVICE_NAME is running."
    else
      echo "$SERVICE_NAME is not running."
      exit 1
    fi
    ;;
  load-save)
    # Ensure we get a new save file name
    newsave=${FACTORIO_PATH}/saves/$2.zip
    if [ ! -f "${newsave}" ]; then
      echo "Save \"${newsave}\" does not exist, aborting action!"
      exit 1
    fi

    # Since stopping the server causes a save we have to stop the server to do this
    if is_running; then
      stop_service
    fi

    # Touch the new save file & start the server
    as_user "touch ${newsave}"
    start_service

    ;;
  screen)
    if is_running; then
      as_user "script /dev/null -q -c \"screen -rx $SCREEN_NAME\""
    else
      echo -n "Server is not running. Do you want to start it? [n]: "
      read START_SERVER
      case "$START_SERVER" in
        [Yy])
          start_service
          as_user "script /dev/null -q -c \"screen -rx $SCREEN_NAME\""
          ;;
        *)
          clear
          echo "Aborting startup!"
          exit 1
          ;;
      esac
    fi
    ;;
  install|update)
    update "$2"
    ;;
  help|--help|-h)
    usage
    ;;
  *)
    echo "No such command!"
    echo
    usage
    exit 1
    ;;
esac

exit 0
